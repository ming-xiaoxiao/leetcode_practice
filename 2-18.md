# 112. Path Sum

<font color = #FF0000><u>2020年2月6日</u></font>

> TAG——二叉树

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

> Example:
>
> Given the below binary tree and sum = 22,
>
>      	 5
>      	/ \
>     	4   8
>     	/   / \
>       11  13  4
>      /  \      \
>     7    2      1
>     return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/path-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## SOLUTION  1：递归DFS + map

> 一开始想到用vector保存是否有这个数据，但是由于有负数，只好改成用map映射。。。终于有一个自己会的了233333

```c++
class Solution {
public:
    map<int,int> mp;
    void culSum(TreeNode* root, int s)
    {
        if(root == nullptr)
            return;
        s += root->val;
        if(root->left == nullptr && root->right == nullptr)
        {
            mp[s] = 1;
            return;
        }
        culSum(root->left,s);
        culSum(root->right,s);
        return ;
    }
    bool hasPathSum(TreeNode* root, int sum) {
        culSum(root,0);
        return mp.count(sum) == 0?false:true;
    }
};
```

> 执行用时 :12 ms, 在所有 C++ 提交中击败了86.72%的用户
>
> 内存消耗 :20.8 MB, 在所有 C++ 提交中击败了5.10%的用户

## SOLUTION 2：递归

> 这个是答案中的代码，自认为写的很简洁。
>
> 拿下来学习一下xx

```c++
bool hasPathSum(TreeNode* root, int sum) {
      if(!root)
          return false;
      if(root->val==sum&&root->left==NULL&&root->right==NULL)
          return true;
      return hasPathSum(root->left,sum-root->val)||hasPathSum(root->right,sum-root->val);
        
    }
```

> 