---
title: 39. Combination Sum
date: 2020-02-28 22:21:09
author: wang
toc: true
top: false
cover: false
summary: 组合数之和
categories: Leetcode
tags:
  - c++
  - medium
  - 递归
  - 回溯
---

# 39. Combination Sum

> TAG——数组、递归、回溯算法

Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.



> Example 1:
>
> Input: candidates = [2,3,6,7], target = 7,
> A solution set is:
> [
>   [7],
>   [2,2,3]
> ]
> Example 2:
>
> Input: candidates = [2,3,5], target = 8,
> A solution set is:
> [
>   [2,2,2,2],
>   [2,3,3],
>   [3,5]
> ]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/combination-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## SOLUTION ：回溯法

> 用target依次去剪candidates。得到一个树：
>
> 当剪到做差为0时，则就是我们要的序列
>
> 否则回溯。

```c++
class Solution {

private:
    vector<vector<int>> ans;
    vector<int> candidates;
    vector<int> path;

public:
    void DFS(int start, int target)
    {
        if(target == 0)
        {
            ans.push_back(path);
            return;
        }

        for(int i = start; i < candidates.size() && target - candidates[i] >= 0; i++)
        {
            path.push_back(candidates[i]);
            DFS(i,target - candidates[i]);
            path.pop_back();
        }
    }


    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        std::sort(candidates.begin(),candidates.end());
        this->candidates = candidates;
        DFS(0,target);
        
        return ans;
    }
};
```

> 执行用时 :12 ms, 在所有 C++ 提交中击败了78.93%的用户
>
> 内存消耗 :13.6 MB, 在所有 C++ 提交中击败了24.80%的用户
