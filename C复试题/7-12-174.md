---
title: 174. 地下城游戏
date: 2020-07-12 11:55:23
author: wang
toc: true
top: false
cover: false
summary: 逆向dp
categories: Leetcode
tags:
  - hard
  - python
  - 动态规划
---

# 174. 地下城游戏

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。






> 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
>
> -2 (K)	-3	3
> -5	-10	1
> 10	30	-5 (P)
>
>
> 说明:
>
> 骑士的健康点数没有上限。
>
> 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。
> 通过次数12,659提交次数29,248
>
> 
>
> 
>
> 
>
> 



## 整体分析

## SOLUTION  1：逆向dp

> 状态定义：`dp[i][j]`骑士从i,j出发走到右下角这一全部过程中血量都**不小于1**的 最初血量，最后求得`DP[0][0]`即可
>
> 初始&状态转移：
>
> 1. 对于最右下角的`dp[m - 1][n - 1] = max(1, 1-dungeon[[m - 1][n - 1])`
>    1. 如果`dungeon[[m - 1][n - 1]<0`，则dp为`1-dungeon[[m - 1][n - 1]`(要让生命值保持在大于等于1)
>    2. 如果`dungeon[[m - 1][n - 1]>0`，则dp为1表示只要让生命值在这里保持大于等于1即可，取最小值1
> 2. 同1理，让最后一行和最后一列的dp都满足最少为1
> 3. 除去最后一行最后一列，剩下元素的状态转移：
>    * 由于`dp[i][j]`只能由下或者右转换而来，所以这里取下和右的最小值-当前dungeon
>
> 
>

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        m = len(dungeon)
        n = len(dungeon[0])

        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 最后一个点点
        dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])
        # 最后一行
        for j in range(n - 2, -1, -1):
            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j])
        # 最后一列
        for i in range(m - 2, -1, -1):
            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1])
        for i in range(m - 2, -1, -1):
            for j in range(n - 2, -1, -1):
                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])
        return dp[0][0]
                



```

> 执行用时：56 ms, 在所有 Python3 提交中击败了69.43%的用户
>
> 内存消耗：14.4 MB, 在所有 Python3 提交中击败了100.00%的用户


