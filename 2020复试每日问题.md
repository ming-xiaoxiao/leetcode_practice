[TOC]

# 2020年2月20日

1. c99支持Variable length arrays，但是考试中，这种情况算错误

```c
int n;
int a[n];
```

2. ***p1++**

   后缀++的优先级和\*相同，运算结合方向是从右往左，所以等价于\*(p1++)

   即取p1指向的值，再将p1指向下一个变量的地址

3. **++\*p1**

   前缀++和*优先级相同，所以等价于++( *p1)
   
4. 前后缀问题：

   1. ++a  等价于   a =a+1; return a;
   2. a++  等价于   int temp ; temp = a; a= a+1;return temp;  （temp是个临时变量）

# 2020年2月21日

1. 赋值语句返回的是赋的值
2. switch 语句体通常是一个从 case 标签开始的语句块。**如果在第一个 case 标签之前有语句，这些语句并不会被执行**。
3. 什么是空指针/野指针/指针悬挂？[https://blog.csdn.net/bl520025/article/details/8967648]
4. c语言存储类型关键字：
   1. auto声明自动变量
   2. extern声明外部变量
   3. register声明寄存器变量
   4. static声明静态变量
5. static全局变量和普通全局变量的区别
   1. 静态全局变量只能在**定义该变量的源文件**内有效，且只初始化一次（防止在其他文件中使用）
   2. 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 
   3. 补充：把**局部变量**改变为**静态局部变量**后是改变了它的存储方式即改变了它的生存期。把**全局变量**改变为**静态变量**后是改变了它的作用域，限制了它的使用范围。

# 2020年2月22日

1. 字符数组和字符串（以\0结尾的字符数组），字符串长度不包含\0

2. char *s = "hello~"

   1. 这是一个字符串常量
   2. 实际上应该是const char *s，但由于历史原因编译器不接受带const的写法
   3. 这种情况不能写，因为字符串常量保存在代码段是只读的

   ```c
   eg.
   	char *s = "hello";
   	char *s1 = "hello";
   
   	printf("%p\n", s);
   	printf("%p\n", s1);
   
   //上面两个输出一样
   ```

3. char s[] = "hello"

   1. 他说这个字符串就在我这里
   2. 2中说我指向这个字符串
   3. s不允许直接赋值，只能通过数组来对元素一一赋值
   
4. 什么时候用指针，什么时候用数组

   1. 数组：系统回收【构造字符串】
   2. 指针：只读，动态分配，回收【处理字符串】

5. c语言中的排序：

   ```c
   int cmp(const void*a,const void *b)
   {
       return *(int*)a-*(int*)b;
   }
   int main()
   {
   	int *array;
   	int n;
   	scanf("%d",&n);
       //动态分配内存
   	array=(int*)malloc(n*sizeof(int));
   	for(int i = 0; i<n; i++) {
   		scanf("%d",(array+i));
   	}
   	qsort(array, n, sizeof(int),cmp);
   	for(int i=0;i<n;i++) {
   		printf("%d\t",array[i]);
   	}
   	return 0;
   }
   ```

# 2020年2月23日

1. 对于字符串，用%s输入输出，注意%s代表一个单词，空格和回车都是它的分隔符。

2. 如果有%7s这种形式，则是规定了传入字符最多7个的说明，也就是当字符数组定义为char a[8];时，（最后一个是\0）处理的最多字符个数

3. 常见错误：

   ```c
   char *string;
   scanf("%s", string);//无法对字符串常量进行写操作
   ```

4. 字符串数组：char *a[]={"1","aa","sdaffd"}

   1. 由于[ ] 的优先级高于* 所以a先和 [ ]结合，因此他是一个数组，数组中的元素才是char * ，前面讲到char * 是一个变量，保存的地址。

# 2020年2月24日

1. strcpy和strcat都可能出现安全问题，当dst没有足够空间的时候
2. 安全的方式：strncpy和strncat，strncmp：比较前几个的大小

```c
int main()
{
	char str[8] = "asd";
	char str1[] = "fgh";
	strncat_s(str, str1,3);		//此处要注意str是否越界
	printf("%s", str);
}
```

3. strchr函数：找某个字符

```c
int main()
{
	char str[] = "asdasd";
	char *s = strchr(str, 'a');
	s = strchr(s+1, 'a');	//find第二个a
	printf("%s\n", s);
	return 0;
}
```

# 2020年2月25日

1. 二维数组不能传递给二级指针：

```c
int a[3][4] = { 1,1,2,3,4,5,6,7,8,9,10,11 };
	int ** p;
	printf("%d\n", sizeof(a));
	printf("%d\n", sizeof(p));
	//错的方法:a指向的是一维数组大小48，p指向int*大小为4
	p = (int**)a;
	printf("%d\n", p);	//输出a[0][0]的地址
	printf("%d\n", *p);		//输出a[0][0]的值【1】
	printf("%d\n", **p);	//输出a[0][0]为地址的值【1地址的值】报错
	//对的方法
	int(*p1)[4] = a;
```

2. 二维数组分配空间问题：

```c
int** p = (int **)malloc(sizeof(int *) * 3);
	//给p[0][?]分配5个空间
	*p = (int *)malloc(sizeof(int) * 5);
	//给p[1][?]分配4个空间
	*(p+1) = (int *)malloc(sizeof(int) * 4);
	(*p)[0] = 0;	//p[0][0]
	(*p)[1] = 1;
	(*p)[2] = 3;
	*(p+1)[0] = 3;		//p[1][0]
	printf("%d", p[1][0]);
```

# 2020年2月26日

1. typedef struct node{...}aNode;和struct node{...}aNode;
   1. 前者将struct node指明为aNode，所以定义时就可以aNode n1;
   2. 后者声明了一个结构体名为node，且定义了一个node类型的变量叫aNode，
2. union实例：

```c
typedef union {
	int i;
	char ch[sizeof(int)];
}CHI;

int main()
{
	CHI chi;
	int i;
	chi.i = 1234;	//0x0004D2
	for (int i = 0; i < sizeof(int); i++)
	{
		printf("%02hhX", chi.ch[i]);
	}
	printf("\n");
	return 0;
} 
//输出D2040000是因为x86cpu是小端
```

# 2020年2月27日

1. 全局变量只能用编译时已知的值初始化，不能用变量初始化  
2. 出现同名变量，范围小的那个会把范围大的覆盖/隐藏
3. static本地/局部变量：实际上就是全局变量，生存期和全局变量一样，唯一不同是作用域，static本地变量是全局生存期本地作用域，全局变量全是全局
4. 返回本地变量的地址是危险的：因为这个变量出函数后可能会被其他变量占用
5. 带参数的宏的原则：一切都要括号。还有不要加分号！！

# 2020年3月3日

1. 函数参数求值顺序`自右至左`

```c
int a = 0;
printf("%d\n%d\n", a,a++); 	//1,0
```

2. 0代表8进制，0x代表16进制

# 2020年3月4日

1. 刷题过程中遇到的问题：c语言memset函数最后一个参数代表要初始化的内存长度，而不是数组长度，比如int数组a初始化为0就应该写`memset(a,0,n*sizeof(int))`